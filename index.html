<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>My Fishing Log</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="preconnect" href="https://www.gstatic.com">
  <link rel="preconnect" href="https://www.googleapis.com">
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="app fade-in">
    <header>
      <h1>My Fishing Log</h1>
      <p>Track your catches anywhere â€“ with login & cloud sync.</p>
    </header>

    <!-- LOADING -->
    <div id="loadingCard" class="loading-spinner-wrapper">
      <div class="loading-spinner"></div>
    </div>

    <!-- AUTH -->
    <div class="card" id="authCard" style="display:none;">
      <h2>Log in or sign up</h2>

      <label>Email</label>
      <input id="authEmail" type="email">

      <label>Password</label>
      <input id="authPassword" type="password">

      <div class="auth-buttons">
        <button id="loginBtn">Log in</button>
        <button id="signupBtn" class="secondary-btn">Sign up</button>
      </div>

      <p id="authMessage" class="auth-message"></p>
    </div>

    <!-- USER CARD -->
    <div class="card" id="userCard" style="display:none;">
      <div class="user-row">
        <div>
          <div class="user-label">Logged in as</div>
          <div class="user-email" id="userEmail"></div>
        </div>
        <button id="logoutBtn" class="secondary-btn">Log out</button>
      </div>
    </div>

    <!-- MAIN CONTENT -->
    <div id="appContent" style="display:none;">

      <!-- GLOBAL STATS -->
      <div class="card">
        <h2>Stats</h2>
        <div id="stats" class="stats-container">
          <p class="empty-state">No stats yet â€“ add your first catch!</p>
        </div>
      </div>

      <!-- PREDICTIONS -->
      <div class="card">
        <h2>Predictions</h2>
        <p style="font-size:0.8rem; opacity:0.7; margin-top:0;">
          Best spots for the next 3 days, based on your past catches with similar weather.
          Score shows how strong the match is (0â€“100%).
        </p>
        <div id="predictionsContainer" class="predictions-container">
          <p class="empty-state">Not enough data yet â€“ add more catches with weather.</p>
        </div>
      </div>

      <!-- FISHING SPOTS -->
      <div class="card">
        <div class="spots-header-row">
          <h2>My fishing spots</h2>
          <button id="goAddSpotBtn" class="tiny-secondary-btn">Add new spot</button>
        </div>

        <div id="spotsContainer" class="spots-container"></div>
      </div>
    </div>
  </div>

  <!-- FIREBASE + APP LOGIC -->
  <script type="module">
    import { initializeApp }
      from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";

    import {
      getAuth, onAuthStateChanged,
      signInWithEmailAndPassword,
      createUserWithEmailAndPassword,
      signOut
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";

    import {
      getFirestore, collection, getDocs,
      query, where
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

    /* FIREBASE CONFIG */
    const firebaseConfig = {
      apiKey: "AIzaSyCXIdT74cNDSVIoMs3NZ86tPf2kzFm8Iug",
      authDomain: "fishing-log-app-murx.firebaseapp.com",
      projectId: "fishing-log-app-murx",
      storageBucket: "fishing-log-app-murx.firebasestorage.app",
      messagingSenderId: "1656807867882",
      appId: "1:1656807867882:web:e59ddd8f6353d190080e93"
    };

    /* INIT */
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getFirestore(app);

    /* UI ELEMENTS */
    const loadingCard = document.getElementById("loadingCard");
    const authCard    = document.getElementById("authCard");
    const userCard    = document.getElementById("userCard");
    const appContent  = document.getElementById("appContent");
    const userEmailEl = document.getElementById("userEmail");

    const emailEl = document.getElementById("authEmail");
    const passEl  = document.getElementById("authPassword");
    const msgEl   = document.getElementById("authMessage");

    let currentUser = null;
    let catches = [];
    let spots = [];

    /* AUTH BUTTONS */
    document.getElementById("loginBtn").onclick = async () => {
      try { await signInWithEmailAndPassword(auth, emailEl.value, passEl.value); }
      catch (err) { msgEl.textContent = err.message; }
    };

    document.getElementById("signupBtn").onclick = async () => {
      try { await createUserWithEmailAndPassword(auth, emailEl.value, passEl.value); }
      catch (err) { msgEl.textContent = err.message; }
    };

    document.getElementById("logoutBtn").onclick = () => signOut(auth);

    document.getElementById("goAddSpotBtn").onclick = () =>
      window.location.href = "add-spot.html";

    /* AUTH STATE HANDLING */
    onAuthStateChanged(auth, async (user) => {
      currentUser = user;
      loadingCard.style.display = "none";

      if (user) {
        authCard.style.display   = "none";
        userCard.style.display   = "block";
        appContent.style.display = "block";
        userEmailEl.textContent  = user.email;

        await Promise.all([loadCatches(), loadSpots()]);
        renderStats();
        await renderPredictions();
        renderSpots();
      } else {
        authCard.style.display   = "block";
        userCard.style.display   = "none";
        appContent.style.display = "none";
      }
    });

    /* LOAD DATA */
    async function loadCatches() {
      const q = query(collection(db, "catches"), where("userId", "==", currentUser.uid));
      const snap = await getDocs(q);
      catches = snap.docs.map(d => ({ id: d.id, ...d.data() }));
    }

    async function loadSpots() {
      const q = query(collection(db, "spots"), where("userId", "==", currentUser.uid));
      const snap = await getDocs(q);
      spots = snap.docs.map(d => ({ id: d.id, ...d.data() }));
    }

    /* RENDER GLOBAL STATS */
    function renderStats() {
      const statsEl = document.getElementById("stats");
      statsEl.innerHTML = "";

      if (!catches.length) {
        statsEl.innerHTML = `<p class="empty-state">No stats yet â€“ add your first catch!</p>`;
        return;
      }

      const total = catches.length;
      let biggest = catches[0];
      let sum = 0;

      catches.forEach(c => {
        const w = Number(c.weightKg) || 0;
        sum += w;
        if (w > Number(biggest.weightKg || 0)) biggest = c;
      });

      const avg = sum / total;

      const container = document.createElement("div");

      function pill(label, value) {
        const div = document.createElement("div");
        div.className = "stat-pill";
        div.innerHTML = `<span class="stat-label">${label}</span>
                         <span class="stat-value">${value}</span>`;
        container.appendChild(div);
      }

      pill("Total catches", total);
      pill("Biggest fish", `${Number(biggest.weightKg).toFixed(2)} kg ${biggest.species}`);
      pill("Average weight", `${avg.toFixed(2)} kg`);

      statsEl.appendChild(container);
    }

    // ðŸ”Ž Map Open-Meteo weather codes to icon + label
    function getWeatherIconAndLabel(code) {
      if (code === 0) return { icon: "â˜€ï¸", label: "Clear sky" };
      if (code === 1) return { icon: "ðŸŒ¤ï¸", label: "Mainly clear" };
      if (code === 2) return { icon: "â›…", label: "Partly cloudy" };
      if (code === 3) return { icon: "â˜ï¸", label: "Overcast" };
      if (code === 45 || code === 48) return { icon: "ðŸŒ«ï¸", label: "Fog" };
      if (code >= 51 && code <= 57) return { icon: "ðŸŒ¦ï¸", label: "Drizzle" };
      if (code >= 61 && code <= 67) return { icon: "ðŸŒ§ï¸", label: "Rain" };
      if (code >= 71 && code <= 77) return { icon: "ðŸŒ¨ï¸", label: "Snow" };
      if (code >= 80 && code <= 82) return { icon: "ðŸŒ¦ï¸", label: "Rain showers" };
      if (code >= 85 && code <= 86) return { icon: "ðŸŒ¨ï¸", label: "Snow showers" };
      if (code === 95) return { icon: "â›ˆï¸", label: "Thunderstorm" };
      if (code === 96 || code === 99) return { icon: "â›ˆï¸", label: "Thunderstorm with hail" };
      return { icon: "â“", label: "Unknown weather" };
    }

    /* WEATHER HELPER FOR SPOTS: current weather (Open-Meteo, km/h â†’ m/s) */
    async function fetchWeatherForSpot(lat, lng, el) {
      try {
        el.textContent = "Weather: loadingâ€¦";

        const url =
          `https://api.open-meteo.com/v1/forecast` +
          `?latitude=${lat}&longitude=${lng}` +
          `&current_weather=true`;

        const res = await fetch(url);
        if (!res.ok) throw new Error("Open-Meteo error");

        const data = await res.json();
        const cw = data.current_weather || {};

        const temp    = typeof cw.temperature === "number" ? cw.temperature : null;
        const windKmh = typeof cw.windspeed === "number" ? cw.windspeed : null;
        const windMs  = windKmh != null ? windKmh / 3.6 : null;
        const code    = cw.weathercode;

        const { icon, label } = getWeatherIconAndLabel(code);

        const parts = [];
        if (label)          parts.push(label);
        if (temp != null)   parts.push(`${temp.toFixed(1)} Â°C`);
        if (windMs != null) parts.push(`wind ${windMs.toFixed(1)} m/s`);

        const text = parts.join(", ");

        el.textContent = text
          ? `Weather now: ${icon} ${text}`
          : "Weather: not available";
      } catch (err) {
        console.error(err);
        el.textContent = "Weather: failed to load";
      }
    }

    /* FORECAST CACHE FOR PREDICTIONS + per-spot per-day percent store */
    const forecastCache = {};
    // spotId -> { dateString -> percent }
    const spotPredictionPerDay = {};

    async function getForecastForSpot(spot) {
      if (!spot || typeof spot.latitude !== "number" || typeof spot.longitude !== "number") {
        return null;
      }
      if (forecastCache[spot.id]) {
        return forecastCache[spot.id];
      }

      const url =
        `https://api.open-meteo.com/v1/forecast` +
        `?latitude=${spot.latitude}&longitude=${spot.longitude}` +
        `&daily=temperature_2m_max,windspeed_10m_max,weathercode,surface_pressure_mean` +
        `&forecast_days=7&timezone=auto`;

      const res = await fetch(url);
      if (!res.ok) {
        throw new Error("Forecast error");
      }

      const data = await res.json();
      const daily = data.daily || {};
      const times  = daily.time || [];
      const temps  = daily.temperature_2m_max || [];
      const winds  = daily.windspeed_10m_max || [];
      const codes  = daily.weathercode || [];
      const pressures = daily.surface_pressure_mean || daily.mean_surface_pressure || [];

      const days = [];
      for (let i = 0; i < times.length; i++) {
        const t = temps[i];
        const w = winds[i];
        const c = codes[i];
        const p = Array.isArray(pressures) ? pressures[i] : undefined;
        if (typeof t !== "number" || typeof w !== "number") continue;
        days.push({
          date: times[i],              // "YYYY-MM-DD"
          temp: t,
          windMs: w / 3.6,            // km/h â†’ m/s
          code: c,
          pressure: typeof p === "number" ? p : null   // hPa
        });
      }

      const result = { days };
      forecastCache[spot.id] = result;
      return result;
    }

    // Weekday short labels: Sun., Mon., Tues., Wed., Thurs., Fri., Sat.
    function formatWeekdayShort(dateStr) {
      const d = new Date(dateStr + "T12:00:00");
      const idx = d.getDay();
      const names = ["Sun.", "Mon.", "Tues.", "Wed.", "Thurs.", "Fri.", "Sat."];
      return names[idx] ?? dateStr;
    }

    /* PREDICTIONS: next 3 days, score 0â€“100% + per-spot per-day scores */
    async function renderPredictions() {
      const container = document.getElementById("predictionsContainer");
      container.innerHTML = "";

      // reset per-spot per-day scores
      for (const key in spotPredictionPerDay) {
        delete spotPredictionPerDay[key];
      }

      // Only use catches that have temp + wind; pressure is optional
      const catchesWithWeather = catches.filter(c =>
        c.spotId &&
        typeof c.weatherTemp === "number" &&
        typeof c.weatherWindMs === "number"
      );

      if (catchesWithWeather.length < 5) {
        container.innerHTML =
          `<p class="empty-state">Not enough data yet â€“ you need at least 5 catches with weather.</p>`;
        return;
      }

      // Map spots by id
      const spotMap = new Map(spots.map(s => [s.id, s]));

      // Group catches by spotId
      const catchesBySpot = {};
      for (const c of catchesWithWeather) {
        if (!catchesBySpot[c.spotId]) catchesBySpot[c.spotId] = [];
        catchesBySpot[c.spotId].push(c);
      }

      // We track the best spot per date (for the next 3 days)
      const predictionsByDate = new Map();

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      for (const [spotId, spotCatches] of Object.entries(catchesBySpot)) {
        const spot = spotMap.get(spotId);
        if (!spot || typeof spot.latitude !== "number" || typeof spot.longitude !== "number") {
          continue;
        }

        let forecast;
        try {
          forecast = await getForecastForSpot(spot);
        } catch (err) {
          console.error("Forecast error for spot", spotId, err);
          continue;
        }
        if (!forecast || !forecast.days.length) continue;

        for (const day of forecast.days) {
          // Restrict to today + next 2 days (3 days total)
          const dObj = new Date(day.date + "T00:00:00");
          const diffDays = Math.round((dObj - today) / (1000 * 60 * 60 * 24));
          if (diffDays < 0 || diffDays > 2) continue; // only next 3 days

          let score = 0;
          let matches = 0;

          for (const c of spotCatches) {
            const tCatch = c.weatherTemp;
            const wCatch = c.weatherWindMs;
            const pCatch = typeof c.weatherPressure === "number" ? c.weatherPressure : null;

            const tDiff = Math.abs(day.temp - tCatch);
            const wDiff = Math.abs(day.windMs - wCatch);

            // Pressure difference if both exist
            let pDiff = null;
            if (pCatch != null && day.pressure != null) {
              pDiff = Math.abs(day.pressure - pCatch);
            }

            // basic similarity thresholds
            if (tDiff > 4 || wDiff > 3) continue;
            if (pDiff != null && pDiff > 8) continue; // 8 hPa difference = too different

            matches++;

            const base        = 1;
            const weightBonus = Math.max(0, Number(c.weightKg) || 0);
            const tempPenalty = tDiff / 4;    // up to 1
            const windPenalty = wDiff / 3;    // up to 1
            const pressPenalty = pDiff != null ? (pDiff / 20) : 0; // 20 hPa diff ~ 1

            let closeness = 1 - tempPenalty - windPenalty - pressPenalty;
            if (closeness < 0) closeness = 0;

            score += (base + weightBonus) * closeness;
          }

          if (matches === 0) continue;

          const existing = predictionsByDate.get(day.date);
          if (!existing || score > existing.score) {
            predictionsByDate.set(day.date, {
              spot,
              date: day.date,
              score,
              matches,
              temp: day.temp,
              windMs: day.windMs,
              code: day.code
            });
          }
        }
      }

      const predictions = Array.from(predictionsByDate.values());

      if (!predictions.length) {
        container.innerHTML =
          `<p class="empty-state">No useful predictions yet for the next 3 days â€“ add more catches with weather.</p>`;
        return;
      }

      // Sort by date ascending (next 3 days)
      predictions.sort((a, b) => a.date.localeCompare(b.date));

      // Convert scores to 0â€“100% (relative within these days)
      const scores = predictions.map(p => p.score);
      const maxScore = Math.max(...scores);
      const minScore = Math.min(...scores);
      const range = maxScore - minScore || 1;

      predictions.forEach(p => {
        const normalized = (p.score - minScore) / range; // 0..1
        p.percent = Math.round(normalized * 100);

        // Save percent for this spot & this date (used in spots list)
        const sid = p.spot.id;
        if (!spotPredictionPerDay[sid]) spotPredictionPerDay[sid] = {};
        spotPredictionPerDay[sid][p.date] = p.percent;
      });

      // Build Predictions card UI
      predictions.forEach(p => {
        const item = document.createElement("div");
        item.className = "prediction-item";

        const dateObj = new Date(p.date + "T12:00:00");
        const dateStr = dateObj.toLocaleDateString();

        const { icon, label } = getWeatherIconAndLabel(p.code);
        const weatherText =
          `${label}, ${p.temp.toFixed(1)} Â°C, wind ${p.windMs.toFixed(1)} m/s`;

        item.innerHTML = `
          <div class="prediction-top">
            <div class="prediction-spot-name">${p.spot.name || "Unnamed spot"}</div>
            <div class="prediction-date">${dateStr}</div>
          </div>
          <div class="prediction-weather">
            Forecast: ${icon} ${weatherText}
          </div>
          <div class="prediction-score">
            Score: ${p.percent}% (based on ${p.matches} similar catch${p.matches === 1 ? "" : "es"})
          </div>
        `;

        container.appendChild(item);
      });
    }

    /* RENDER SPOTS WITH CURRENT WEATHER + PER-DAY PREDICTION SCORE */
    function renderSpots() {
      const spotsEl = document.getElementById("spotsContainer");
      spotsEl.innerHTML = "";

      if (!spots.length) {
        spotsEl.innerHTML = `<p class="empty-state">No fishing spots yet.</p>`;
        return;
      }

      spots
        .slice()
        .sort((a, b) => (a.name || "").localeCompare(b.name || ""))
        .forEach(spot => {

          const spotCatches = catches.filter(c => c.spotId === spot.id);
          const total = spotCatches.length;

          let biggest = null;
          spotCatches.forEach(c => {
            const w = Number(c.weightKg) || 0;
            if (!biggest || w > Number(biggest.weightKg || 0)) biggest = c;
          });

          const statsLine = total
            ? `Total catches: ${total} â€¢ Biggest: ${Number(biggest.weightKg).toFixed(2)} kg ${biggest.species}`
            : "No catches yet at this spot";

          const hasCoords =
            typeof spot.latitude === "number" &&
            typeof spot.longitude === "number";

          const mapsLink = hasCoords
            ? `https://www.google.com/maps?q=${spot.latitude},${spot.longitude}`
            : "";

          // Build per-day prediction text for this spot, if any
          let predictionLine = "";
          const perDay = spotPredictionPerDay[spot.id];
          if (perDay) {
            const dates = Object.keys(perDay).sort();
            const parts = dates.map(d => {
              const label = formatWeekdayShort(d);
              const pct = perDay[d];
              return `${label} ${pct}%`;
            });
            if (parts.length) {
              predictionLine =
                `<div class="spot-prediction">Prediction score: ${parts.join(", ")}</div>`;
            }
          }

          const block = document.createElement("div");
          block.className = "spot-block";

          block.innerHTML = `
            <div class="spot-header">
              <div class="spot-name-buttons">
                <!-- Spot name -->
                <a class="tiny-secondary-btn"
                   href="spot.html?id=${encodeURIComponent(spot.id)}">
                   ${spot.name || "Unnamed spot"}
                </a>

                <!-- Google Maps -->
                ${
                  hasCoords
                    ? `<a class="tiny-secondary-btn" href="${mapsLink}" target="_blank">
                         Google Maps
                       </a>`
                    : ""
                }

                <!-- Add catch for this spot -->
                <a class="tiny-secondary-btn"
                   href="add-catch.html?spotId=${encodeURIComponent(spot.id)}">
                   Add catch
                </a>
              </div>

              <div class="spot-count">${total} catches</div>
            </div>

            <div class="spot-stats">${statsLine}</div>
            <div class="spot-weather"></div>
            ${predictionLine}
          `;

          const weatherEl = block.querySelector(".spot-weather");

          if (hasCoords) {
            fetchWeatherForSpot(spot.latitude, spot.longitude, weatherEl);
          } else {
            weatherEl.textContent = "Weather: no GPS for this spot";
          }

          spotsEl.appendChild(block);
        });
    }
  </script>
</body>
</html>
