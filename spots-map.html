<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>My Fishing Spots ‚Äì Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="style.css" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    #map {
      margin-top: 10px;
      height: 420px;
      border-radius: 18px;
      overflow: hidden;
    }

    .map-legend {
      margin-top: 10px;
      font-size: 0.85rem;
      opacity: 0.85;
    }

    .popup-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .popup-stats {
      font-size: 0.8rem;
      margin-bottom: 4px;
    }

    .popup-weather-text,
    .popup-pred-text {
      font-size: 0.8rem;
      margin-bottom: 4px;
    }

    .popup-links {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }

    .popup-links a {
      text-decoration: none;
    }

    .popup-pred-lines {
      margin-top: 2px;
    }
  </style>
</head>

<body>
  <div class="app fade-in">
    <header>
      <h1>My fishing spots ‚Äì map</h1>
      <p>See all your spots on an interactive map with live weather & predictions.</p>
    </header>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
        <h2 style="margin:0;">Spots overview</h2>
        <button class="secondary-btn" onclick="window.location.href='index.html'">
          ‚Üê Back to main
        </button>
      </div>

      <div id="map"></div>

      <div class="map-legend">
        ‚Ä¢ Marker color (tomorrow): <span style="color:#22c55e;">‚óè</span> good (‚â•70%), 
        <span style="color:#eab308;">‚óè</span> medium (40‚Äì69%), 
        <span style="color:#ef4444;">‚óè</span> poor (&lt;40%).<br/>
        ‚Ä¢ Popup shows live weather now and prediction for the next 3 days.
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Firebase + map logic -->
  <script type="module">
    import { initializeApp }
      from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";

    import {
      getAuth,
      onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";

    import {
      getFirestore,
      collection, getDocs,
      query, where
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

    /* FIREBASE CONFIG (same as index.html) */
    const firebaseConfig = {
      apiKey: "AIzaSyCXIdT74cNDSVIoMs3NZ86tPf2kzFm8Iug",
      authDomain: "fishing-log-app-murx.firebaseapp.com",
      projectId: "fishing-log-app-murx",
      storageBucket: "fishing-log-app-murx.firebasestorage.app",
      messagingSenderId: "1056807867882",
      appId: "1:1056807867882:web:e59ddd8f6353d190080e93"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db   = getFirestore(app);

    let currentUser = null;

    // Weekday shorts
    const WEEKDAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];

    /* ---------- WEATHER ICON & LABEL (shared with other pages) ---------- */
    function getWeatherIconAndLabel(code) {
      if (code === 0) return { icon: "‚òÄÔ∏è", label: "Clear sky" };
      if (code === 1) return { icon: "üå§Ô∏è", label: "Mainly clear" };
      if (code === 2) return { icon: "‚õÖ", label: "Partly cloudy" };
      if (code === 3) return { icon: "‚òÅÔ∏è", label: "Overcast" };
      if (code === 45 || code === 48) return { icon: "üå´Ô∏è", label: "Fog" };
      if (code >= 51 && code <= 57) return { icon: "üå¶Ô∏è", label: "Drizzle" };
      if (code >= 61 && code <= 67) return { icon: "üåßÔ∏è", label: "Rain" };
      if (code >= 71 && code <= 77) return { icon: "üå®Ô∏è", label: "Snow" };
      if (code >= 80 && code <= 82) return { icon: "üå¶Ô∏è", label: "Rain showers" };
      if (code >= 85 && code <= 86) return { icon: "üå®Ô∏è", label: "Snow showers" };
      if (code === 95) return { icon: "‚õàÔ∏è", label: "Thunderstorm" };
      if (code === 96 || code === 99) return { icon: "‚õàÔ∏è", label: "Thunderstorm with hail" };
      return { icon: "‚ùì", label: "Unknown" };
    }

    function formatDateLabel(dateObj) {
      const d = dateObj.getDate();
      const m = dateObj.getMonth() + 1;
      const y = dateObj.getFullYear();
      const weekday = WEEKDAYS[dateObj.getDay()];
      return `${weekday} ${d}.${m}.${y}`;
    }

    /* ---------- CORE PREDICTION LOGIC (COPY SAME TO predictions.html) ---------- */

    // Compute a prediction score (0‚Äì100) for one forecast (temp, wind, pressure, moon)
    function computePredictionScoreForDay(spotCatches, forecastTemp, forecastWindMs, forecastPress, forecastMoonPhase) {
      const usable = spotCatches.filter(c =>
        typeof c.weatherTemp     === "number" &&
        typeof c.weatherWindMs   === "number" &&
        typeof c.weatherPressure === "number"
      );

      if (!usable.length) return null;

      const scores = usable.map(c => {
        let penalty = 0;

        const tempDiff = Math.abs(c.weatherTemp - forecastTemp);
        if (tempDiff > 5) {
          penalty += (tempDiff - 5) * 2;
        }

        const windDiff = Math.abs(c.weatherWindMs - forecastWindMs);
        if (windDiff > 4) {
          penalty += (windDiff - 4) * 3;
        }

        if (forecastPress < 1000) {
          if (c.weatherPressure >= 1000) penalty += 10;
        } else {
          if (c.weatherPressure < 1000)  penalty += 10;
        }

        const catchMoon = typeof c.moonPhase === "number" ? c.moonPhase : null;
        if (catchMoon != null && typeof forecastMoonPhase === "number") {
          const moonDiff = Math.abs(catchMoon - forecastMoonPhase);
          penalty += moonDiff * 40;
        }

        let score = 100 - penalty;
        if (score < 0) score = 0;
        if (score > 100) score = 100;
        return score;
      });

      return scores.reduce((a, b) => a + b, 0) / scores.length;
    }

    // Fetch weather + predictions for next 3 days for a spot
    async function computeSpotWeatherAndPredictions(lat, lng, spotCatches) {
      let weatherText = "Weather: failed to load";

      const predictions = []; // [{score, dateLabel}, ...]

      try {
        const url =
          `https://api.open-meteo.com/v1/forecast` +
          `?latitude=${lat}&longitude=${lng}` +
          `&current_weather=true` +
          `&hourly=temperature_2m,windspeed_10m,surface_pressure` +
          `&daily=moon_phase` +
          `&forecast_days=4` +
          `&timezone=auto`;

        const res = await fetch(url);
        if (!res.ok) throw new Error("Open-Meteo error");
        const data = await res.json();

        // Live weather
        const cw = data.current_weather || {};
        const tempNow    = typeof cw.temperature === "number" ? cw.temperature : null;
        const windKmhNow = typeof cw.windspeed === "number" ? cw.windspeed : null;
        const windMsNow  = windKmhNow != null ? windKmhNow / 3.6 : null;
        const codeNow    = cw.weathercode;

        const { icon, label } = getWeatherIconAndLabel(codeNow);
        const wParts = [];
        if (label)          wParts.push(label);
        if (tempNow != null)wParts.push(`${tempNow.toFixed(1)} ¬∞C`);
        if (windMsNow != null) wParts.push(`wind ${windMsNow.toFixed(1)} m/s`);

        weatherText = wParts.length
          ? `Weather now: ${icon} ${wParts.join(", ")}`
          : "Weather: not available";

        // Forecast arrays
        const hourly = data.hourly || {};
        const times  = hourly.time || [];
        const temps  = hourly.temperature_2m || [];
        const windsK = hourly.windspeed_10m || [];
        const presses= hourly.surface_pressure || [];

        const daily = data.daily || {};
        const dTimes = daily.time || [];
        const dMoon  = daily.moon_phase || [];

        if (!times.length || !temps.length || !windsK.length || !presses.length || !dTimes.length || !dMoon.length) {
          return { weatherText, predictions };
        }

        // Helper to get forecast+moon for a given day offset
        function getForecastForDayOffset(dayOffset) {
          const base = new Date();
          base.setDate(base.getDate() + dayOffset);
          const yyyy = base.getFullYear();
          const mm = String(base.getMonth() + 1).padStart(2, "0");
          const dd = String(base.getDate()).padStart(2, "0");
          const dateStr = `${yyyy}-${mm}-${dd}`;

          let idx = times.findIndex(t => t.startsWith(`${dateStr}T12`));
          if (idx === -1) {
            idx = times.findIndex(t => t.startsWith(dateStr));
          }
          if (idx === -1) return null;

          const fTemp = temps[idx];
          const fWindMs = windsK[idx] / 3.6;
          const fPress = presses[idx];

          const dIdx = dTimes.findIndex(t => t === dateStr);
          const fMoon = dIdx >= 0 ? dMoon[dIdx] : null;

          return { dateObj: base, temp: fTemp, windMs: fWindMs, press: fPress, moon: fMoon };
        }

        // Next 3 days: offsets 1, 2, 3
        for (let offset = 1; offset <= 3; offset++) {
          const fc = getForecastForDayOffset(offset);
          if (!fc) {
            predictions.push({
              score: null,
              dateLabel: formatDateLabel(new Date(new Date().setDate(new Date().getDate() + offset)))
            });
            continue;
          }

          const score = computePredictionScoreForDay(
            spotCatches,
            fc.temp,
            fc.windMs,
            fc.press,
            fc.moon
          );

          predictions.push({
            score,
            dateLabel: formatDateLabel(fc.dateObj)
          });
        }

      } catch (err) {
        console.error("Weather/prediction error:", err);
      }

      return { weatherText, predictions };
    }

    /* ---------- AUTH + MAP INITIALISATION ---------- */

    onAuthStateChanged(auth, async (user) => {
      if (!user) {
        window.location.href = "index.html";
        return;
      }

      currentUser = user;
      await initMapPage();
    });

    async function initMapPage() {
      const [spots, catches] = await Promise.all([
        loadSpots(),
        loadCatches()
      ]);

      const map = L.map("map").setView([59.0, 25.0], 6);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(map);

      const bounds = [];

      for (const spot of spots) {
        if (typeof spot.latitude !== "number" || typeof spot.longitude !== "number") {
          continue;
        }

        const spotCatches = catches.filter(c => c.spotId === spot.id);

        let statsLine = "No catches yet";
        if (spotCatches.length) {
          let biggest = spotCatches[0];
          spotCatches.forEach(c => {
            if (Number(c.weightKg) > Number(biggest.weightKg)) {
              biggest = c;
            }
          });
          statsLine =
            `Total catches: ${spotCatches.length}, ` +
            `biggest: ${Number(biggest.weightKg).toFixed(2)} kg ${biggest.species}`;
        }

        const { weatherText, predictions } =
          await computeSpotWeatherAndPredictions(spot.latitude, spot.longitude, spotCatches);

        const mapsLink =
          `https://www.google.com/maps?q=${spot.latitude},${spot.longitude}`;

        // Marker color based on tomorrow‚Äôs score
        let markerColor = "#60a5fa"; // neutral blue default
        const tomorrowPred = predictions[0];
        if (tomorrowPred && typeof tomorrowPred.score === "number") {
          const s = tomorrowPred.score;
          if (s >= 70) markerColor = "#22c55e";     // green
          else if (s >= 40) markerColor = "#eab308"; // yellow
          else markerColor = "#ef4444";             // red
        }

        // Build prediction text lines
        let predHtml = "Prediction (next 3 days):<br/><div class='popup-pred-lines'>";
        predictions.forEach(p => {
          const val = (p && typeof p.score === "number")
            ? `${p.score.toFixed(0)}%`
            : "n/a";
          predHtml += `${p.dateLabel}: ${val}<br/>`;
        });
        predHtml += "</div>";

        const popupHtml = `
          <div class="popup-title">${spot.name}</div>
          <div class="popup-stats">${statsLine}</div>
          <div class="popup-weather-text">${weatherText}</div>
          <div class="popup-pred-text">${predHtml}</div>
          <div class="popup-links">
            <a class="tiny-secondary-btn"
               href="spot.html?id=${encodeURIComponent(spot.id)}">
              Open spot
            </a>
            <a class="tiny-secondary-btn"
               href="add-catch.html?spotId=${encodeURIComponent(spot.id)}">
              Add catch
            </a>
            <a class="tiny-secondary-btn"
               href="${mapsLink}" target="_blank">
              Google Maps
            </a>
          </div>
        `;

        const marker = L.circleMarker(
          [spot.latitude, spot.longitude],
          {
            radius: 8,
            color: markerColor,
            fillColor: markerColor,
            fillOpacity: 0.9,
            weight: 2
          }
        ).addTo(map);

        marker.bindPopup(popupHtml);
        bounds.push([spot.latitude, spot.longitude]);
      }

      if (bounds.length > 0) {
        map.fitBounds(bounds, { padding: [30, 30] });
      }
    }

    /* ---------- LOAD DATA HELPERS ---------- */
    async function loadSpots() {
      const q = query(
        collection(db, "spots"),
        where("userId", "==", currentUser.uid)
      );
      const snap = await getDocs(q);
      return snap.docs.map(d => ({ id: d.id, ...d.data() }));
    }

    async function loadCatches() {
      const q = query(
        collection(db, "catches"),
        where("userId", "==", currentUser.uid)
      );
      const snap = await getDocs(q);
      return snap.docs.map(d => ({ id: d.id, ...d.data() }));
    }
  </script>
</body>
</html>
